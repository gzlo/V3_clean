#!/bin/bash
# ===================== MOODLE BACKUP - WRAPPER SCRIPT V3 =====================
# Script wrapper mejorado para manejo multi-cliente de moodle_backup.sh
# Permite selecciÃ³n interactiva de clientes y gestiÃ³n de cron
# Autor: Sistema Moodle Backup
# =====================================================================

# Colores
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m'
BOLD='\033[1m'

# ConfiguraciÃ³n
SCRIPT_NAME="moodle_backup.sh"
SCRIPT_FULL_PATH=""
CONFIG_DIR="/etc/moodle-backup/configs"

# Funciones de logging
log_info() { echo -e "${BLUE}â„¹ï¸  $*${NC}"; }
log_success() { echo -e "${GREEN}âœ… $*${NC}"; }
log_warning() { echo -e "${YELLOW}âš ï¸  $*${NC}"; }
log_error() { echo -e "${RED}âŒ $*${NC}"; }

# Buscar el script principal en ubicaciones comunes
find_main_script() {
    local possible_locations=(
        "/usr/local/bin/moodle-backup/moodle_backup.sh"
        "/usr/local/bin/moodle_backup.sh"
        "$HOME/bin/moodle_backup.sh"
        "$(dirname "$0")/moodle_backup.sh"
        "./moodle_backup.sh"
    )
    
    for location in "${possible_locations[@]}"; do
        if [[ -f "$location" ]] && [[ -x "$location" ]]; then
            SCRIPT_FULL_PATH="$location"
            return 0
        fi
    done
    
    log_error "No se encontrÃ³ moodle_backup.sh en ubicaciones conocidas"
    echo "Ubicaciones verificadas:"
    printf "  - %s\n" "${possible_locations[@]}"
    exit 1
}

# Mostrar header del menÃº principal
print_menu_header() {
    clear
    echo -e "${BLUE}${BOLD}"
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘                    MOODLE BACKUP V3 - GESTOR MULTI-CLIENTE                 â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo -e "${NC}"
}

# Listar configuraciones disponibles
list_configurations() {
    local configs=()
    local descriptions=()
    local statuses=()
    
    if [[ ! -d "$CONFIG_DIR" ]]; then
        log_warning "No se encontrÃ³ el directorio de configuraciones: $CONFIG_DIR"
        return 1
    fi
    
    # Leer archivo de estados de cron
    local cron_status_file="$CONFIG_DIR/.cron_status"
    declare -A cron_states
    if [[ -f "$cron_status_file" ]]; then
        while IFS=: read -r client status schedule; do
            cron_states["$client"]="$status"
        done < "$cron_status_file"
    fi
    
    # Buscar archivos de configuraciÃ³n
    for config_file in "$CONFIG_DIR"/*.conf; do
        if [[ -f "$config_file" ]]; then
            local client_name=$(basename "$config_file" .conf)
            local client_desc=""
            
            # Extraer descripciÃ³n del archivo
            if [[ -f "$config_file" ]]; then
                client_desc=$(grep "^CLIENT_DESCRIPTION=" "$config_file" | cut -d'"' -f2 2>/dev/null || echo "Sin descripciÃ³n")
            fi
            
            # Determinar estado del cron
            local cron_status="${cron_states[$client_name]:-unknown}"
            local status_icon=""
            case "$cron_status" in
                "enabled") status_icon="${GREEN}ğŸŸ¢ Activo${NC}" ;;
                "disabled") status_icon="${RED}ğŸ”´ Inactivo${NC}" ;;
                *) status_icon="${YELLOW}â“ Desconocido${NC}" ;;
            esac
            
            configs+=("$client_name")
            descriptions+=("$client_desc")
            statuses+=("$status_icon")
        fi
    done
    
    if [[ ${#configs[@]} -eq 0 ]]; then
        log_warning "No se encontraron configuraciones de clientes"
        log_info "Ejecute el instalador para crear configuraciones"
        return 1
    fi
    
    echo ""
    echo -e "${CYAN}${BOLD}CONFIGURACIONES DISPONIBLES:${NC}"
    echo ""
    
    for i in "${!configs[@]}"; do
        local num=$((i + 1))
        printf "%2d. ${GREEN}%-15s${NC} - %s - %s\n" "$num" "${configs[i]}" "${descriptions[i]}" "${statuses[i]}"
    done
    
    echo ""
    return 0
}

# MenÃº principal de selecciÃ³n
show_main_menu() {
    print_menu_header
    
    if ! list_configurations; then
        echo ""
        log_info "Para crear configuraciones, ejecute el instalador:"
        echo "   bash <(curl -fsSL https://raw.githubusercontent.com/gzlo/moodle-backup/main/install-interactive.sh)"
        exit 1
    fi
    
    echo -e "${CYAN}${BOLD}OPCIONES DISPONIBLES:${NC}"
    echo ""
    echo "  [1-N]  Ejecutar backup para cliente especÃ­fico"
    echo "  list   Mostrar lista de configuraciones"
    echo "  on     Habilitar cron para un cliente"
    echo "  off    Deshabilitar cron para un cliente"
    echo "  status Ver estado de todos los clientes"
    echo "  logs   Ver logs recientes"
    echo "  help   Mostrar ayuda completa"
    echo "  exit   Salir"
    echo ""
    
    read -r -p "Seleccione una opciÃ³n: " choice
    echo ""
    
    case "$choice" in
        [0-9]*)
            execute_backup_by_number "$choice"
            ;;
        "list")
            list_configurations
            wait_for_enter
            ;;
        "on")
            enable_cron_interactive
            ;;
        "off")
            disable_cron_interactive
            ;;
        "status")
            show_all_status
            wait_for_enter
            ;;
        "logs")
            show_recent_logs
            wait_for_enter
            ;;
        "help")
            show_full_help
            wait_for_enter
            ;;
        "exit"|"quit"|"q")
            log_info "Â¡Hasta luego!"
            exit 0
            ;;
        *)
            log_warning "OpciÃ³n invÃ¡lida: $choice"
            wait_for_enter
            ;;
    esac
}

# Ejecutar backup por nÃºmero de cliente
execute_backup_by_number() {
    local selection="$1"
    
    # Obtener lista de configuraciones
    local configs=()
    for config_file in "$CONFIG_DIR"/*.conf; do
        if [[ -f "$config_file" ]]; then
            configs+=($(basename "$config_file" .conf))
        fi
    done
    
    # Validar selecciÃ³n
    if ! [[ "$selection" =~ ^[0-9]+$ ]] || [[ "$selection" -lt 1 ]] || [[ "$selection" -gt ${#configs[@]} ]]; then
        log_error "SelecciÃ³n invÃ¡lida: $selection"
        log_info "Debe ser un nÃºmero entre 1 y ${#configs[@]}"
        wait_for_enter
        return 1
    fi
    
    # Obtener configuraciÃ³n seleccionada
    local index=$((selection - 1))
    local client_name="${configs[index]}"
    local config_file="$CONFIG_DIR/$client_name.conf"
    
    log_info "Ejecutando backup para cliente: $client_name"
    
    # Confirmar ejecuciÃ³n
    read -r -p "Â¿Confirma la ejecuciÃ³n del backup? [y/N]: " confirm
    if [[ ! "$confirm" =~ ^[yY]$ ]]; then
        log_info "EjecuciÃ³n cancelada"
        wait_for_enter
        return 0
    fi
    
    # Ejecutar backup
    echo ""
    log_info "Iniciando backup en segundo plano..."
    
    # Ejecutar con configuraciÃ³n especÃ­fica
    CONFIG_FILE="$config_file" nohup "$SCRIPT_FULL_PATH" > "/tmp/mb_$client_name.log" 2>&1 &
    local pid=$!
    
    echo "$pid" > "/tmp/moodle_backup_${client_name}_pid"
    
    log_success "Backup iniciado con PID: $pid"
    log_info "Para seguir el progreso: tail -f /tmp/mb_$client_name.log"
    log_info "Para ver el estado: mb status"
    
    wait_for_enter
}

# Habilitar cron interactivamente
enable_cron_interactive() {
    echo -e "${CYAN}${BOLD}HABILITAR CRON PARA CLIENTE${NC}"
    echo ""
    
    # Mostrar clientes disponibles
    local configs=()
    for config_file in "$CONFIG_DIR"/*.conf; do
        if [[ -f "$config_file" ]]; then
            local client_name=$(basename "$config_file" .conf)
            configs+=("$client_name")
        fi
    done
    
    if [[ ${#configs[@]} -eq 0 ]]; then
        log_warning "No hay configuraciones disponibles"
        wait_for_enter
        return 1
    fi
    
    echo "Clientes disponibles:"
    for i in "${!configs[@]}"; do
        echo "  $((i + 1)). ${configs[i]}"
    done
    echo ""
    
    read -r -p "Seleccione cliente (1-${#configs[@]}): " selection
    
    if ! [[ "$selection" =~ ^[0-9]+$ ]] || [[ "$selection" -lt 1 ]] || [[ "$selection" -gt ${#configs[@]} ]]; then
        log_error "SelecciÃ³n invÃ¡lida"
        wait_for_enter
        return 1
    fi
    
    local client_name="${configs[$((selection - 1))]}"
    enable_cron_for_client "$client_name"
    wait_for_enter
}

# Deshabilitar cron interactivamente
disable_cron_interactive() {
    echo -e "${CYAN}${BOLD}DESHABILITAR CRON PARA CLIENTE${NC}"
    echo ""
    
    # Mostrar clientes con cron habilitado
    local enabled_clients=()
    local cron_status_file="$CONFIG_DIR/.cron_status"
    
    if [[ -f "$cron_status_file" ]]; then
        while IFS=: read -r client status schedule; do
            if [[ "$status" == "enabled" ]]; then
                enabled_clients+=("$client")
            fi
        done < "$cron_status_file"
    fi
    
    if [[ ${#enabled_clients[@]} -eq 0 ]]; then
        log_warning "No hay clientes con cron habilitado"
        wait_for_enter
        return 1
    fi
    
    echo "Clientes con cron habilitado:"
    for i in "${!enabled_clients[@]}"; do
        echo "  $((i + 1)). ${enabled_clients[i]}"
    done
    echo ""
    
    read -r -p "Seleccione cliente (1-${#enabled_clients[@]}): " selection
    
    if ! [[ "$selection" =~ ^[0-9]+$ ]] || [[ "$selection" -lt 1 ]] || [[ "$selection" -gt ${#enabled_clients[@]} ]]; then
        log_error "SelecciÃ³n invÃ¡lida"
        wait_for_enter
        return 1
    fi
    
    local client_name="${enabled_clients[$((selection - 1))]}"
    disable_cron_for_client "$client_name"
    wait_for_enter
}

# FunciÃ³n para habilitar cron
enable_cron_for_client() {
    local client_name="$1"
    local config_file="$CONFIG_DIR/$client_name.conf"
    
    if [[ ! -f "$config_file" ]]; then
        log_error "No se encontrÃ³ configuraciÃ³n para: $client_name"
        return 1
    fi
    
    log_info "Habilitando cron para: $client_name"
    
    # Leer configuraciÃ³n de cron del archivo
    local cron_frequency=$(grep "^CRON_FREQUENCY=" "$config_file" | cut -d'"' -f2)
    local cron_hour=$(grep "^CRON_HOUR=" "$config_file" | cut -d'"' -f2)
    
    # Generar expresiÃ³n cron
    local cron_expression=""
    case "$cron_frequency" in
        "daily") cron_expression="0 $cron_hour * * *" ;;
        "every_2_days") cron_expression="0 $cron_hour */2 * *" ;;
        "weekly") cron_expression="0 $cron_hour * * 0" ;;
        "biweekly") cron_expression="0 $cron_hour 1,15 * *" ;;
        "monthly") cron_expression="0 $cron_hour 1 * *" ;;
        *) cron_expression="$cron_frequency" ;;
    esac
    
    # Comando del cron
    local cron_command="CONFIG_FILE=$config_file $SCRIPT_FULL_PATH >/dev/null 2>&1"
    local cron_line="$cron_expression $cron_command # Moodle Backup - $client_name"
    
    # Agregar al crontab
    (crontab -l 2>/dev/null || echo "") | grep -v "# Moodle Backup - $client_name" | { cat; echo "$cron_line"; } | crontab -
    
    # Actualizar archivo de estado
    local cron_status_file="$CONFIG_DIR/.cron_status"
    if [[ -f "$cron_status_file" ]]; then
        sed -i "/^$client_name:/d" "$cron_status_file"
    fi
    echo "$client_name:enabled:$cron_expression" >> "$cron_status_file"
    
    log_success "Cron habilitado para $client_name: $cron_expression"
}

# FunciÃ³n para deshabilitar cron
disable_cron_for_client() {
    local client_name="$1"
    
    log_info "Deshabilitando cron para: $client_name"
    
    # Remover del crontab
    (crontab -l 2>/dev/null || echo "") | grep -v "# Moodle Backup - $client_name" | crontab -
    
    # Actualizar archivo de estado
    local cron_status_file="$CONFIG_DIR/.cron_status"
    if [[ -f "$cron_status_file" ]]; then
        sed -i "/^$client_name:enabled:/c\\$client_name:disabled:" "$cron_status_file"
    fi
    
    log_success "Cron deshabilitado para: $client_name"
}

# Mostrar estado de todos los clientes
show_all_status() {
    echo -e "${CYAN}${BOLD}ESTADO DE TODOS LOS CLIENTES${NC}"
    echo ""
    
    if [[ ! -d "$CONFIG_DIR" ]]; then
        log_warning "No se encontrÃ³ directorio de configuraciones"
        return 1
    fi
    
    local found_any=false
    
    for config_file in "$CONFIG_DIR"/*.conf; do
        if [[ -f "$config_file" ]]; then
            found_any=true
            local client_name=$(basename "$config_file" .conf)
            local client_desc=$(grep "^CLIENT_DESCRIPTION=" "$config_file" | cut -d'"' -f2 2>/dev/null || echo "Sin descripciÃ³n")
            
            echo -e "${GREEN}Cliente: $client_name${NC}"
            echo "  DescripciÃ³n: $client_desc"
            
            # Estado del cron
            local cron_status_file="$CONFIG_DIR/.cron_status"
            local cron_status="desconocido"
            if [[ -f "$cron_status_file" ]]; then
                cron_status=$(grep "^$client_name:" "$cron_status_file" | cut -d: -f2 2>/dev/null || echo "desconocido")
            fi
            
            case "$cron_status" in
                "enabled") echo -e "  Cron: ${GREEN}ğŸŸ¢ Habilitado${NC}" ;;
                "disabled") echo -e "  Cron: ${RED}ğŸ”´ Deshabilitado${NC}" ;;
                *) echo -e "  Cron: ${YELLOW}â“ Desconocido${NC}" ;;
            esac
            
            # Verificar proceso en ejecuciÃ³n
            local pid_file="/tmp/moodle_backup_${client_name}_pid"
            if [[ -f "$pid_file" ]]; then
                local pid=$(cat "$pid_file")
                if ps -p "$pid" >/dev/null 2>&1; then
                    echo -e "  Estado: ${BLUE}ğŸ”„ EjecutÃ¡ndose (PID: $pid)${NC}"
                else
                    echo -e "  Estado: ${YELLOW}â¸ï¸  Inactivo${NC}"
                fi
            else
                echo -e "  Estado: ${YELLOW}â¸ï¸  Inactivo${NC}"
            fi
            
            # Ãšltimo log
            local log_file=$(grep "^LOG_FILE=" "$config_file" | cut -d'"' -f2 2>/dev/null)
            if [[ -f "$log_file" ]]; then
                local last_backup=$(tail -n 20 "$log_file" | grep "BACKUP COMPLETADO" | tail -n 1 | cut -d' ' -f1-2)
                if [[ -n "$last_backup" ]]; then
                    echo "  Ãšltimo backup: $last_backup"
                else
                    echo "  Ãšltimo backup: No encontrado"
                fi
            else
                echo "  Log: No disponible"
            fi
            
            echo ""
        fi
    done
    
    if [[ "$found_any" != "true" ]]; then
        log_warning "No se encontraron configuraciones de clientes"
    fi
}

# FunciÃ³n para esperar Enter
wait_for_enter() {
    echo ""
    read -r -p "Presiona Enter para continuar..."
}

# Mostrar logs recientes
show_recent_logs() {
    echo -e "${CYAN}${BOLD}LOGS RECIENTES${NC}"
    echo ""
    
    # Preguntar de quÃ© cliente mostrar logs
    local configs=()
    for config_file in "$CONFIG_DIR"/*.conf; do
        if [[ -f "$config_file" ]]; then
            configs+=($(basename "$config_file" .conf))
        fi
    done
    
    if [[ ${#configs[@]} -eq 0 ]]; then
        log_warning "No hay configuraciones disponibles"
        return 1
    fi
    
    echo "Seleccione cliente:"
    for i in "${!configs[@]}"; do
        echo "  $((i + 1)). ${configs[i]}"
    done
    echo "  0. Todos los clientes"
    echo ""
    
    read -r -p "SelecciÃ³n: " selection
    
    if [[ "$selection" == "0" ]]; then
        # Mostrar logs de todos los clientes
        for client in "${configs[@]}"; do
            local config_file="$CONFIG_DIR/$client.conf"
            local log_file=$(grep "^LOG_FILE=" "$config_file" | cut -d'"' -f2 2>/dev/null)
            
            echo -e "${GREEN}=== LOGS DE $client ===${NC}"
            if [[ -f "$log_file" ]]; then
                tail -n 10 "$log_file"
            else
                echo "No se encontrÃ³ archivo de log"
            fi
            echo ""
        done
    else
        if ! [[ "$selection" =~ ^[0-9]+$ ]] || [[ "$selection" -lt 1 ]] || [[ "$selection" -gt ${#configs[@]} ]]; then
            log_error "SelecciÃ³n invÃ¡lida"
            return 1
        fi
        
        local client_name="${configs[$((selection - 1))]}"
        local config_file="$CONFIG_DIR/$client_name.conf"
        local log_file=$(grep "^LOG_FILE=" "$config_file" | cut -d'"' -f2 2>/dev/null)
        
        echo -e "${GREEN}=== LOGS DE $client_name ===${NC}"
        if [[ -f "$log_file" ]]; then
            tail -n 30 "$log_file"
            echo ""
            log_info "Para seguimiento en tiempo real: tail -f $log_file"
        else
            log_warning "No se encontrÃ³ archivo de log: $log_file"
        fi
    fi
}

# Mostrar ayuda completa
show_full_help() {
    cat << 'EOF'
ğŸš€ MOODLE BACKUP V3 - GESTOR MULTI-CLIENTE

COMANDOS PRINCIPALES:
  mb                    MenÃº interactivo de selecciÃ³n de clientes
  mb list               Listar todas las configuraciones disponibles
  mb on <cliente>       Habilitar cron para un cliente especÃ­fico
  mb off <cliente>      Deshabilitar cron para un cliente especÃ­fico
  mb status             Ver estado de todos los clientes
  mb logs               Ver logs recientes de un cliente
  mb help               Mostrar esta ayuda

EJEMPLOS DE USO:
  mb                    # Abrir menÃº interactivo
  mb list               # Ver lista de clientes configurados
  mb on cliente1        # Habilitar cron para cliente1
  mb off cliente1       # Deshabilitar cron para cliente1
  mb status             # Ver estado de todos los clientes

GESTIÃ“N DE CRON:
  â€¢ Los cron jobs se manejan individualmente por cliente
  â€¢ Cada cliente puede tener diferentes horarios y frecuencias
  â€¢ Use 'mb on/off' para habilitar/deshabilitar sin perder la configuraciÃ³n

ARCHIVOS DE CONFIGURACIÃ“N:
  â€¢ UbicaciÃ³n: /etc/moodle-backup/configs/
  â€¢ Un archivo .conf por cliente
  â€¢ Estado de cron en: .cron_status

LOGS:
  â€¢ Cada cliente tiene su propio archivo de log
  â€¢ UbicaciÃ³n definida en su configuraciÃ³n
  â€¢ Use 'mb logs' para acceso rÃ¡pido

Para ayuda del script principal: CONFIG_FILE=<archivo> mb --help
EOF
}

# FunciÃ³n principal
main() {
    # Buscar script principal
    find_main_script
    
    # Verificar argumentos
    if [[ $# -eq 0 ]]; then
        # MenÃº interactivo en bucle
        while true; do
            show_main_menu
        done
    else
        # Comandos directos
        case "$1" in
            "list")
                print_menu_header
                list_configurations
                ;;
            "on")
                if [[ -n "$2" ]]; then
                    enable_cron_for_client "$2"
                else
                    log_error "Debe especificar el nombre del cliente"
                    echo "Uso: mb on <cliente>"
                fi
                ;;
            "off")
                if [[ -n "$2" ]]; then
                    disable_cron_for_client "$2"
                else
                    log_error "Debe especificar el nombre del cliente"
                    echo "Uso: mb off <cliente>"
                fi
                ;;
            "status")
                print_menu_header
                show_all_status
                ;;
            "logs")
                print_menu_header
                show_recent_logs
                ;;
            "help"|"--help")
                show_full_help
                ;;
            *)
                # Pasar argumentos al script principal
                CONFIG_FILE="${CONFIG_FILE:-}" "$SCRIPT_FULL_PATH" "$@"
                ;;
        esac
    fi
}

# Ejecutar funciÃ³n principal
main "$@"

COMANDOS DE MONITOREO:
  mb status             Estado del Ãºltimo backup
  mb logs               Ver logs recientes  
  mb clean              Limpiar archivos temporales antiguos

OPCIONES AVANZADAS (compatibilidad completa):
  mb --help             Ayuda completa con todas las opciones
  mb --diagnose         DiagnÃ³sticos avanzados del sistema
  mb --test-rclone      Prueba especÃ­fica de Google Drive
  mb --show-config      ConfiguraciÃ³n con validaciÃ³n completa

EJEMPLOS:
  mb                              # Backup en segundo plano (recomendado)
  mb interactive                  # Backup en primer plano
  mb config                       # Ver configuraciÃ³n
  mb test                         # Probar conectividad
  mb logs                         # Ver logs recientes
  mb status                       # Estado del proceso
  
CONFIGURACIÃ“N FLEXIBLE:
  PANEL_TYPE=plesk mb config          # Forzar tipo de panel
  REQUIRE_CONFIG=false mb config      # Permitir auto-detecciÃ³n
  CLIENT_NAME=test mb                 # Backup con nombre especÃ­fico

MONITOREO AVANZADO:
  mb logs 50                          # Ver mÃ¡s lÃ­neas de log
  tail -f /var/log/moodle_backup.log  # Seguimiento en tiempo real
  
EJECUCIÃ“N EN SEGUNDO PLANO:
  Por defecto, 'mb' ejecuta el backup en segundo plano usando nohup.
  Esto permite que continÃºe aunque cierre la sesiÃ³n SSH.
  Use 'mb interactive' si necesita ver la salida en tiempo real.

Para ayuda completa del script principal: mb help
EOF
}

# FunciÃ³n para mostrar logs recientes
show_recent_logs() {
    local log_file="/var/log/moodle_backup.log"
    local lines="${1:-30}"
    
    echo "=== LOGS RECIENTES (Ãºltimas $lines lÃ­neas) ==="
    echo ""
    
    if [[ -f "$log_file" ]]; then
        # Verificar si hay proceso en ejecuciÃ³n para ofrecer seguimiento
        if [[ -f /tmp/moodle_backup_last_pid ]]; then
            local last_pid=$(cat /tmp/moodle_backup_last_pid)
            if ps -p "$last_pid" >/dev/null 2>&1; then
                echo "ğŸ”„ Proceso activo detectado (PID: $last_pid)"
                echo "ğŸ’¡ Para seguimiento en tiempo real: tail -f $log_file"
                echo ""
            fi
        fi
        
        tail -n "$lines" "$log_file"
        echo ""
        echo "ğŸ’¡ Comandos Ãºtiles:"
        echo "   tail -f $log_file                    # Seguimiento en tiempo real"
        echo "   mb logs 50                           # Ver mÃ¡s lÃ­neas"
        echo "   grep ERROR $log_file                 # Solo errores"
        
    else
        echo "âš ï¸ No se encontrÃ³ archivo de log en: $log_file"
        echo ""
        echo "Posibles ubicaciones alternativas:"
        for alt_log in "/tmp/moodle_backup*.log" "/var/log/moodle*.log"; do
            if ls $alt_log >/dev/null 2>&1; then
                echo "  ğŸ“ Encontrado: $alt_log"
            fi
        done
    fi
}

# FunciÃ³n para limpiar archivos temporales
clean_temp_files() {
    local tmp_patterns=(
        "/tmp/moodle_backup*"
        "/tmp/backup_*"
        "/var/tmp/moodle_backup*"
    )
    
    echo "ğŸ§¹ Limpiando archivos temporales antiguos..."
    
    for pattern in "${tmp_patterns[@]}"; do
        # Eliminar archivos mÃ¡s antiguos de 7 dÃ­as
        find $(dirname "$pattern") -name "$(basename "$pattern")" -mtime +7 -type f 2>/dev/null | while read -r file; do
            echo "  Eliminando: $file"
            rm -f "$file"
        done
    done
    
    echo "âœ… Limpieza completada"
}

# FunciÃ³n para mostrar estado del Ãºltimo backup
show_backup_status() {
    local log_file="/var/log/moodle_backup.log"
    
    echo "=== ESTADO DEL BACKUP MOODLE ==="
    
    # Verificar proceso en ejecuciÃ³n
    if [[ -f /tmp/moodle_backup_last_pid ]]; then
        local last_pid=$(cat /tmp/moodle_backup_last_pid)
        if ps -p "$last_pid" >/dev/null 2>&1; then
            echo "ğŸ”„ PROCESO ACTIVO:"
            echo "   PID: $last_pid"
            echo "   Estado: EjecutÃ¡ndose en segundo plano"
            echo "   Comando: $(ps -p "$last_pid" -o comm= 2>/dev/null)"
            echo ""
        else
            echo "â¹ï¸  Ãšltimo proceso completado (PID: $last_pid)"
            echo ""
        fi
    fi
    
    if [[ -f "$log_file" ]]; then
        # Buscar la Ãºltima ejecuciÃ³n exitosa
        local last_success=$(grep "âœ….*completado exitosamente" "$log_file" | tail -1)
        local last_error=$(grep "âŒ\|ERROR" "$log_file" | tail -1)
        local last_start=$(grep "INICIANDO BACKUP" "$log_file" | tail -1)
        
        if [[ -n "$last_start" ]]; then
            echo "ğŸš€ Ãšltima ejecuciÃ³n iniciada:"
            echo "   $last_start"
            echo ""
        fi
        
        if [[ -n "$last_success" ]]; then
            echo "âœ… Ãšltimo backup exitoso:"
            echo "   $last_success"
            echo ""
        fi
        
        if [[ -n "$last_error" ]]; then
            echo "âŒ Ãšltimo error detectado:"
            echo "   $last_error"
            echo ""
        fi
        
        # Verificar archivos temporales
        if ls /tmp/moodle_backup* >/dev/null 2>&1; then
            echo "ğŸ“ Archivos temporales encontrados:"
            ls -lah /tmp/moodle_backup* 2>/dev/null | head -5
            echo ""
        fi
        
        # Mostrar Ãºltimas lÃ­neas del log
        echo "ğŸ“‹ Ãšltimas 5 lÃ­neas del log:"
        tail -5 "$log_file" | sed 's/^/   /'
        
    else
        echo "âš ï¸ No se encontrÃ³ archivo de log"
        echo "El backup aÃºn no se ha ejecutado o LOG_FILE no estÃ¡ configurado"
    fi
}

# FunciÃ³n principal
main() {
    # Buscar script principal
    find_main_script
    
    local command="${1:-run}"
    
    case "$command" in
        # Comando por defecto - ejecutar backup en segundo plano
        ""|"run")
            echo "ğŸš€ Iniciando backup de Moodle en segundo plano..."
            echo "ğŸ“‹ Logs del proceso: /var/log/moodle_backup.log"
            echo "ğŸ“‹ Logs de sesiÃ³n: /tmp/moodle_backup_session_*.log"
            echo ""
            echo "ğŸ’¡ Para monitorear el progreso use:"
            echo "   mb logs     - Ver logs recientes"
            echo "   mb status   - Estado del backup"
            echo ""
            
            # Ejecutar en segundo plano con nohup
            nohup "$SCRIPT_FULL_PATH" > /tmp/moodle_backup_wrapper_$(date +%s).log 2>&1 &
            local backup_pid=$!
            
            echo "âœ… Backup iniciado en segundo plano (PID: $backup_pid)"
            echo "ğŸ” El proceso continuarÃ¡ aunque cierre la sesiÃ³n SSH"
            echo ""
            echo "Comandos Ãºtiles:"
            echo "  mb logs     # Ver progreso en tiempo real"
            echo "  mb status   # Estado actual"
            echo "  ps -p $backup_pid  # Verificar si el proceso sigue ejecutÃ¡ndose"
            
            # Guardar PID para referencia
            echo "$backup_pid" > /tmp/moodle_backup_last_pid
            ;;
            
        # Comando interactivo - ejecutar en primer plano
        "interactive"|"foreground"|"fg")
            echo "ğŸ”„ Ejecutando backup en modo interactivo (primer plano)..."
            echo "âš ï¸ NOTA: El proceso se detendrÃ¡ si cierra la sesiÃ³n SSH"
            echo ""
            exec "$SCRIPT_FULL_PATH"
            ;;
            
        # Comandos simples del wrapper (sin dash)
        "config")
            exec "$SCRIPT_FULL_PATH" --show-config
            ;;
        "test")
            exec "$SCRIPT_FULL_PATH" --test-rclone
            ;;
        "help")
            exec "$SCRIPT_FULL_PATH" --help
            ;;
        "diagnose")
            exec "$SCRIPT_FULL_PATH" --diagnose
            ;;
        "version")
            echo "ğŸš€ Moodle Backup V3 - Script Universal Multi-Panel"
            echo "ğŸ“ UbicaciÃ³n: $SCRIPT_FULL_PATH"
            if [[ -f "$SCRIPT_FULL_PATH" ]]; then
                echo "ğŸ“… $(grep "^# Fecha:" "$SCRIPT_FULL_PATH" | head -1 || echo "Fecha: No especificada")"
                echo "ğŸ‘¤ $(grep "^# Autor:" "$SCRIPT_FULL_PATH" | head -1 || echo "Autor: Sistema Moodle Backup")"
                echo "ğŸ”§ $(grep "^# VersiÃ³n:" "$SCRIPT_FULL_PATH" | head -1 || echo "VersiÃ³n: 3.0")"
            fi
            ;;
        "status")
            show_backup_status
            ;;
        "logs")
            # Permitir especificar nÃºmero de lÃ­neas
            local lines="${2:-30}"
            show_recent_logs "$lines"
            ;;
        "clean")
            clean_temp_files
            ;;
            
        # Opciones avanzadas (con dash para compatibilidad)
        "--help"|"-h")
            exec "$SCRIPT_FULL_PATH" --help
            ;;
        "--show-config")
            exec "$SCRIPT_FULL_PATH" --show-config
            ;;
        "--test"|"--test-rclone")
            exec "$SCRIPT_FULL_PATH" --test-rclone
            ;;
        "--diagnose")
            exec "$SCRIPT_FULL_PATH" --diagnose
            ;;
        "--version")
            echo "ğŸš€ Moodle Backup V3 - Script Universal Multi-Panel"
            echo "ğŸ“ UbicaciÃ³n: $SCRIPT_FULL_PATH"
            if [[ -f "$SCRIPT_FULL_PATH" ]]; then
                echo "ğŸ“… $(grep "^# Fecha:" "$SCRIPT_FULL_PATH" | head -1 || echo "Fecha: No especificada")"
                echo "ğŸ‘¤ $(grep "^# Autor:" "$SCRIPT_FULL_PATH" | head -1 || echo "Autor: Sistema Moodle Backup")"
                echo "ğŸ”§ $(grep "^# VersiÃ³n:" "$SCRIPT_FULL_PATH" | head -1 || echo "VersiÃ³n: 3.0")"
            fi
            ;;
            
        # Comandos especiales del wrapper
        "wrapper-help")
            show_wrapper_help
            ;;
            
        # Comando desconocido
        *)
            echo "âŒ Comando desconocido: $command"
            echo ""
            show_wrapper_help
            exit 1
            ;;
    esac
}

# Ejecutar funciÃ³n principal con todos los argumentos
main "$@"
